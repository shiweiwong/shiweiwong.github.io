<!DOCTYPE html>


<html lang="zh-CN">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title>Rxjava |  Shiweiwong&#39;s Blog</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/css/remixicon.min.css"
      />
      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <script src="https://cdn.jsdelivr.net/npm/mermaid@8.9.2/dist/mermaid.min.js"></script>
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    </head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-notes/rxjava"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  Rxjava
</h1>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/notes/rxjava.html" class="article-date">
  <time datetime="2023-12-06T00:20:40.813Z" itemprop="datePublished">2023-12-06</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/notes/">notes</a>
  </div>
  
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> 字数统计:</span>
            <span class="post-count">6.1k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> 阅读时长≈</span>
            <span class="post-count">26 分钟</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="Rxjava-基础知识"><a href="#Rxjava-基础知识" class="headerlink" title="Rxjava 基础知识"></a>Rxjava 基础知识</h1><h2 id="Hot-Observable-和-Cold-Observable"><a href="#Hot-Observable-和-Cold-Observable" class="headerlink" title="Hot Observable 和 Cold Observable"></a>Hot Observable 和 Cold Observable</h2><ul>
<li>Hot Observable 无论有没有订阅观察者, 事件始终会发生, 且各观察者之间共享订阅信息  </li>
<li>Cold Observable 只有订阅观察者时, 才执行发送数据的代码, 各个观察者之间处理事件是独立的, just, create. range, fromXXX 等运算符均生成  Cold Observable 对象   </li>
</ul>
<h2 id="Cold-Observable-向-Hot-Observable-转换"><a href="#Cold-Observable-向-Hot-Observable-转换" class="headerlink" title="Cold Observable 向 Hot Observable 转换"></a>Cold Observable 向 Hot Observable 转换</h2><ol>
<li>调用 publish() 方法生成 ConnectableObservable 对象, 并调用 ConnectableObservable</li>
<li>使用 Subject/Processor (Processor 支持<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/2c4799fa91a4">背压</a>控制)</li>
</ol>
<p><strong>背压:在异步场景中, 被观察者发送事件速度远大于观察者处理事件的速度的情况下, 一种告诉上游的被观察者降低发送速度的策略</strong>  </p>
<h2 id="Hot-Observable-向-Cold-Observable-转换"><a href="#Hot-Observable-向-Cold-Observable-转换" class="headerlink" title="Hot Observable 向 Cold Observable 转换"></a>Hot Observable 向 Cold Observable 转换</h2><ol>
<li>ConnectableObservable 的 refCount 方法  </li>
<li>Observable 的 share 方法(封装了 publish().refCount() 调用)   </li>
</ol>
<h2 id="Flowable"><a href="#Flowable" class="headerlink" title="Flowable"></a>Flowable</h2><p>&emsp;&emsp;Rxjava 2.x 中新增加的被观察者, 强制支持背压, 可以看成 Observable 新的实现.</p>
<h2 id="Single-Completable-和-Maybe"><a href="#Single-Completable-和-Maybe" class="headerlink" title="Single, Completable 和 Maybe"></a>Single, Completable 和 Maybe</h2><p>Rxjava 2.x 中新增加的三种被观察者</p>
<ol>
<li><p><strong>Single</strong>: 只有 onSuccess 和 onError 事件  其中 onSuccess( ) 用于发射数据( 在 Observable/Flowable 中使用 onNext()) 且只能用一次, 后面即使在发射数据也不会做任何处理.<br>可以通过 toXXX() 方法转换成其他被观察者.</p>
</li>
<li><p><strong>Completable</strong>: 在创建后, 不会发射任何数据, 只有 onComplete( ) 和 onError( ) 事件, 没有 map, flatMap 等操作符,可以通过 fromXXX 操作符来创建一个 Completable. 经常和 andThen 操作符结合使用(Completable 执行完毕之后进行 andThen 里的操作);</p>
</li>
<li><p><strong>Maybe</strong>: 有数据发射-&gt; onSuccess, 无数据发射且无错误发生 -&gt; onComplete</p>
</li>
</ol>
<h2 id="Subject-和-Processor"><a href="#Subject-和-Processor" class="headerlink" title="Subject 和 Processor"></a>Subject 和 Processor</h2><h3 id="Subject"><a href="#Subject" class="headerlink" title="Subject"></a>Subject</h3><p>&emsp;&emsp;既可以是 Observable, 也可以是 Observer;</p>
<ol>
<li><strong>AsyncSubject</strong><br>&emsp;&emsp;Observer 会接收 作为 Observable 的 AsyncSubject onComplete() 之前最后一个数据 (必须调用subject.onComplete() 才会开始发送数据)</li>
<li><strong>BehaviorSubject</strong><br>&emsp;&emsp;发送订阅之前消息池中最后一条消息和订阅之后的所有消息</li>
<li><strong>ReplaySubject</strong><br>&emsp;&emsp;发送所有消息<br>&emsp;&emsp;将 create 改成 createWithSize(int) 可以修改订阅之前消息池的大小</li>
<li><strong>PublishSubject</strong><br>&emsp;&emsp;只发送订阅之后的消息  </li>
</ol>
<hr>
<h1 id="据说上面是基础知识"><a href="#据说上面是基础知识" class="headerlink" title="据说上面是基础知识"></a><del>据说上面是基础知识</del></h1><hr>
<h1 id="操作符-写作方法读作操作符"><a href="#操作符-写作方法读作操作符" class="headerlink" title="操作符(写作方法读作操作符)"></a>操作符(写作方法读作操作符)</h1><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><ol>
<li><strong>just()</strong>: 将一个或多个对象转换成发射这个或这些对象的 Observable</li>
<li><strong>from()</strong>: 将一个 Iterable, Futurue 或者一个数组转换成一个 Observable</li>
<li><strong>create()</strong>: 从头创建一个 Observable</li>
<li><strong>defer()</strong>: 只有订阅 Observer 时才创建 Observable, 为每个订阅创建一个新的 Observable</li>
<li><strong>range()</strong>: 创建一个发射指定范围的整数序列的 Observable</li>
<li><strong>interval()</strong>: 创建一个按照给定的事件间隔发射整数序列的 Observable, 按照固定的事件间隔发射一个无限递增的整数序列, 可通过 take(int) 限制上限, 接受一个表示时间间隔的参数和一个表示时间单位的参数, 默认在 computation 调度器上执行.</li>
<li><strong>timer()</strong>: 创建一个在给定的延时之后发射单个数据的 Observable, 参数列表同上, 延迟一段给定时间后发射一个简单的数字 0, 默认同在 computation 调度器上执行.</li>
<li><strong>empty()</strong>: 创建一个什么都不做直接 onComplete() 的Observable  </li>
<li><strong>error()</strong>: 同上, onError()</li>
<li><strong>never()</strong>: 创建一个不发射任何数据的 Observable  </li>
</ol>
<p>实例代码:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Observable.create(new ObservableOnSubscribe&lt;Integer&gt;()&#123;</span><br><span class="line">    /*</span><br><span class="line">     * @param emitter 中文翻译为发射器</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception&#123;</span><br><span class="line">      try&#123;</span><br><span class="line">        // RxJava 建议检测 isDiposed 状态,</span><br><span class="line">        // 以便没有观察者时, 让 Observable 停止发射数据, 防止运行昂贵的运算</span><br><span class="line">        if(!emitter.isDiposed())&#123;</span><br><span class="line">          for(int i=0;i&lt;10;i++)&#123;</span><br><span class="line">            emitter.onNext(i);</span><br><span class="line">          &#125;</span><br><span class="line">          // 一个形式正确的有限 Observable 必须尝试调用观察者的 onComplete()/onError() 一次</span><br><span class="line">          // 且此后不能再调用观察者的任何其他方法</span><br><span class="line">          emitter.onComplete();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;just 类似 from, 但是 from 会将数组或 Iterable 的数据取出然后逐个发射, 而 just 则是当做一个数据一次性发射(对每个参数而言).<br>&emsp;&emsp;just 可以接受一到十个参数, 返回一个按参数列表顺序发射这些数据的 Observable  </p>
<h2 id="repeat"><a href="#repeat" class="headerlink" title="repeat"></a>repeat</h2><p>&emsp;&emsp;创建一个发射特定数据重复多次的  Observable<br>&emsp;&emsp;收到 onComplete() 时触发重新订阅(另一个方法 retry() 是收到 onError() 时重新订阅)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Observable</span><br><span class="line">    .just(&quot;hello repeat&quot;)</span><br><span class="line">    .repeat(3)                //重复3次</span><br><span class="line">    .subscribe(System.out::println)</span><br></pre></td></tr></table></figure>
<p>执行结果  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hello repeat</span><br><span class="line">hello repeat</span><br><span class="line">hello repeat</span><br></pre></td></tr></table></figure>

<h3 id="repeatWhen"><a href="#repeatWhen" class="headerlink" title="repeatWhen"></a>repeatWhen</h3><p>&emsp;&emsp;有条件地重新订阅和重复发射数据  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Observable.range(0,9).repeatWhen(new Function&lt;Observable&lt;Object&gt;, ObservableSource&lt;?&gt;&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public ObservableSource&lt;?&gt; apply(Observable&lt;Object&gt; objectObservable) throws Exception &#123;</span><br><span class="line">                return Observable.timer(10, TimeUnit.SECONDS);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).subscribe(System.out::println);</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;上一个发射的 Observable 作为输入的参数, 返回的 Observable 触发了 onNext()  则重新订阅  </p>
<h3 id="repeatUntil"><a href="#repeatUntil" class="headerlink" title="repeatUntil"></a>repeatUntil</h3><p>&emsp;&emsp;直到某个条件时不再重复订阅  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Observable.interval(500, TimeUnit.MILLISECONDS)</span><br><span class="line">                .take(5)</span><br><span class="line">                .repeatUntil(()-&gt;(System.currentTimeMillis() - startTimeMillis &gt; 5000))</span><br><span class="line">                .subscribe(System.out::println);</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;需要传入 BooleanSupplier() 接口, 当接口方法返回 true 时终止重复订阅  </p>
<h1 id="Rxjava-的线程操作"><a href="#Rxjava-的线程操作" class="headerlink" title="Rxjava 的线程操作"></a>Rxjava 的线程操作</h1><h2 id="调度器-Scheduler-种类"><a href="#调度器-Scheduler-种类" class="headerlink" title="调度器(Scheduler) 种类"></a>调度器(Scheduler) 种类</h2><h3 id="RxJava-线程"><a href="#RxJava-线程" class="headerlink" title="RxJava 线程"></a>RxJava 线程</h3><p>&emsp;&emsp;在默认情况下, RxJava 只在当前线程中运行, 它是单线程的. 此时 Observable 用于发射数据流, Observer 用于接收和响应数据流, 各种操作符用于加工数据流.</p>
<h3 id="Scheduler"><a href="#Scheduler" class="headerlink" title="Scheduler"></a>Scheduler</h3><p>&emsp;&emsp;Scheduler 是 RxJava 对线程控制器的一个抽象.</p>
<table>
<thead>
<tr>
<th align="left">Scheduler</th>
<th align="left">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left">single</td>
<td align="left">使用定长为 1 的线程池, 重复利用同一个线程</td>
</tr>
<tr>
<td align="left">newThread</td>
<td align="left">每次都启用新线程, 并在新线程中执行操作</td>
</tr>
<tr>
<td align="left">computation</td>
<td align="left">使用固定的线程池(Fixed Scheduler Pool), 大小为 CPU 内核数, 适用于 CPU 密集型</td>
</tr>
<tr>
<td align="left">io</td>
<td align="left">适合 I/O 操作(读写文件, 读写数据库, 网络信息交互等)所使用的 Scheduler. 行为和 newThread() 差不多, 区别在于 io() 内部实现是用一个无数量上线的线程池, 可以重用空闲线程, 因此多数情况下, io() 比 newThread() 更有效率, 支持异步阻塞 I/O 操作</td>
</tr>
<tr>
<td align="left">trampoline</td>
<td align="left">直接在当前线程运行, 如果当前线程有其他任务正在执行, 则会先暂停其他任务</td>
</tr>
<tr>
<td align="left">Scheduler.from</td>
<td align="left">将 java.util.concurrent.Executor 转换成一个调度器实例, 即自定义调度器</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(&quot;hello&quot;)</span><br><span class="line">          .observeOn(Schedulers.newThread()) // 切换到 newThread</span><br><span class="line">          .subscribe(System.out::println);</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp; 使用 subscribeOn() 和 observeOn() 切换线程<br>&emsp;&emsp; subscribeOn() 接受一个 Scheduler 参数, 指定对数据的处理运行在特定的线程调度器上. 仅第一次切换有效<br>&emsp;&emsp; observeOn() 接收一个 Scheduler 参数, 用来指定下游操作运行在特定的线程调度器上. 可多次切换</p>
<h3 id="Scheduler-的测试-TestScheduler"><a href="#Scheduler-的测试-TestScheduler" class="headerlink" title="Scheduler 的测试(TestScheduler)"></a>Scheduler 的测试(TestScheduler)</h3><p>&emsp;&emsp;<strong>TestScheduler</strong> 专门用于测试的调度器, 只有被调用时时间才会继续, 非线程安全. 用于测试一些不引入真实并发性, 允许手动推进虚拟事件的调度器. <del>Rxjava1.x Scheduler.test()</del> Rxjava 2.x new TestScheduler  </p>
<ol>
<li><strong>advanceTimeTo(int time, int timeUnit)</strong>  将调度器的时钟移动到到固定的时刻.</li>
<li><strong>advanceTimeBy(int time, int timeUnit)</strong> 按指定的事件向前移动</li>
<li><strong>triggerActions()</strong>: 执行计划中的但是未启动的任务, 并不修改调度器时间<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">TestScheduler scheduler = new TestScheduler();</span><br><span class="line">scheduler.createWorker().schedule(new Runnable()&#123;           </span><br><span class="line"></span><br><span class="line">       @Override</span><br><span class="line">       public void run() &#123;</span><br><span class="line">             System.out.println(&quot;immediate&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">&#125;);</span><br><span class="line">scheduler.createWorker().schedule(new Runnable() &#123;</span><br><span class="line">       @Override</span><br><span class="line">       public void run() &#123;</span><br><span class="line">       System.out.println(&quot;20s&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">&#125;,20, TimeUnit.SECONDS);</span><br><span class="line">System.out.println(&quot;virtual time:&quot; + scheduler.now(TimeUnit.SECONDS));</span><br><span class="line">scheduler.triggerActions();</span><br><span class="line">System.out.println(&quot;virtual time:&quot; + scheduler.now(TimeUnit.SECONDS));</span><br></pre></td></tr></table></figure>
结果  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">virtual time:0</span><br><span class="line">immediate</span><br><span class="line">virtual time:0</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="变换操作符和过滤操作符"><a href="#变换操作符和过滤操作符" class="headerlink" title="变换操作符和过滤操作符"></a>变换操作符和过滤操作符</h1><table>
<thead>
<tr>
<th align="left">变换操作符</th>
<th align="left">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left">map()</td>
<td align="left">对序列的每一项都用一个函数来变换 Observable 发射的数据序列</td>
</tr>
<tr>
<td align="left">flatMap(),<br>concatMap(),<br>flatMapIterable()</td>
<td align="left">将 Observable 发射的数据集合变换为 Observable 集合, 然后将这些 Observable 发射的数据平坦化地放进一个单独的 Observable 中</td>
</tr>
<tr>
<td align="left">switchMap()</td>
<td align="left">将 Observable 发射的数据集合变换为 Observable 集合. 然后只发射这些 Observable 最近发射过的数据</td>
</tr>
<tr>
<td align="left">scan()</td>
<td align="left">对 Observable 发射的每一项数据应用一个函数, 然后按顺序依次发射每一个值.</td>
</tr>
<tr>
<td align="left">groupBy()</td>
<td align="left">将 Observable 拆分为 Observable 结合, 将原始 Observable 发射的数据按  Key 分组, 每一个 Observable 发射一组不同的数据</td>
</tr>
<tr>
<td align="left">buffer()</td>
<td align="left">定期从 Observable 收集数据到一个集合, 然后将这些数据集合打包发射</td>
</tr>
<tr>
<td align="left">window()</td>
<td align="left">定期将来自 Observable 的数据拆分成一些 Observable 窗口, 然后发射这些窗口</td>
</tr>
<tr>
<td align="left">cast()</td>
<td align="left">在发射之前强制将 Observable 发射的所有数据转换为指定类型</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">过滤操作符</th>
<th align="left">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left">filter()</td>
<td align="left">过滤数据, 根据指定的谓词函数测试数据项, 只有通过测试(返回 true )的数据才会发射</td>
</tr>
<tr>
<td align="left">take()</td>
<td align="left">只发射开始的 N 项数据</td>
</tr>
<tr>
<td align="left">takeLast()</td>
<td align="left">只发射最后的 N 项数据</td>
</tr>
<tr>
<td align="left">last()</td>
<td align="left">只发射最后一项数据</td>
</tr>
<tr>
<td align="left">lastOrDefault()</td>
<td align="left">只发射最后一项数据, 如果 Observable 为空, 就发射默认值</td>
</tr>
<tr>
<td align="left">takeLastBuffer()</td>
<td align="left">将最后的 N 项数据当作单个数据发射</td>
</tr>
<tr>
<td align="left">skip()</td>
<td align="left">跳过开始的 N 项数据</td>
</tr>
<tr>
<td align="left">skipLast()</td>
<td align="left">跳过最后的 N 项数据</td>
</tr>
<tr>
<td align="left">first()</td>
<td align="left">发射第一条数据或者默认值</td>
</tr>
<tr>
<td align="left">firstOrError()</td>
<td align="left">发射第一条数据, 如果为空 则 onError()</td>
</tr>
<tr>
<td align="left">elementAt()</td>
<td align="left">发射第 N 项数据</td>
</tr>
<tr>
<td align="left">elementAtOrError()</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">sample()/throttleLast()</td>
<td align="left">定期发射最近的数据</td>
</tr>
<tr>
<td align="left">throttleFirst()</td>
<td align="left">定期发射第一项数据</td>
</tr>
<tr>
<td align="left">throttleWithTimeOut()/debounce()</td>
<td align="left">当 Observable 在指定的时间段后还没有发射数据时, 才发射一个数据</td>
</tr>
<tr>
<td align="left">timeout()</td>
<td align="left">如果在一个指定的时间段后还没有发射数据, 就发射一个异常</td>
</tr>
<tr>
<td align="left">distinct()</td>
<td align="left">过滤掉重复数据(可以接受一个Function 作为参数) 根据返回的 key 值去重</td>
</tr>
<tr>
<td align="left">distinctUntilChanged()</td>
<td align="left">过滤掉连续重复的数据</td>
</tr>
<tr>
<td align="left">ofType()</td>
<td align="left">只发射指定类型的数据</td>
</tr>
<tr>
<td align="left">ignoreElements()</td>
<td align="left">丢弃所有正常数据, 只发射错误或完成的通知</td>
</tr>
</tbody></table>
<h2 id="Map-和-flatMap"><a href="#Map-和-flatMap" class="headerlink" title="Map 和 flatMap"></a>Map 和 flatMap</h2><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>&emsp;&emsp;对原始 Observable 发射的每一项数据应用一个函数, 默认不在任何特定的调度器上执行.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Observable</span><br><span class="line">  .just(&quot;HELLO&quot;)</span><br><span class="line">  .map(String::toLowerCase)</span><br><span class="line">  .map(s-&gt;s+&quot; world&quot;)</span><br><span class="line">  .subscribe(System.out::println);</span><br></pre></td></tr></table></figure>
<p>执行结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello world</span><br></pre></td></tr></table></figure>
<h3 id="flatMap"><a href="#flatMap" class="headerlink" title="flatMap"></a>flatMap</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Observable</span><br><span class="line">    .just(user)</span><br><span class="line">    .flatMap(new Function&lt;User, ObservableSource&lt;User.Address&gt;&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        ObservableSource&lt;User.Address&gt; apply(User user) throws Exception &#123;</span><br><span class="line">            return Observable.fromIterable(user.addresses);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .subscribe(new Consumer&lt;User.Address&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void accept(User.Address address) throws Exception &#123;</span><br><span class="line">            System.out.println(address.street);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<p>以上代码 与 map() 部分等价  </p>
<h4 id="map-与-flatMap-区别"><a href="#map-与-flatMap-区别" class="headerlink" title="map() 与 flatMap() 区别"></a>map() 与 flatMap() 区别</h4><p>&emsp;&emsp;map 只是对原 Observable 发射的内容进行修改, flatMap 返回一个新的 Observable    </p>
<h4 id="concatMap"><a href="#concatMap" class="headerlink" title="concatMap()"></a>concatMap()</h4><p>&emsp;&emsp;flatMap 对 Observable 发射的数据做的时合并操作, 并不保证次序, concatMap() 严格按照顺序发射数据   </p>
<h2 id="groupBy"><a href="#groupBy" class="headerlink" title="groupBy()"></a>groupBy()</h2><p>&emsp;&emsp;根据传递的函数参数给每一项指定一个 Key, 返回一个 GroupedObservable 对象,  key 相同的数据会被同一个 Observable 发射</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Observable</span><br><span class="line">  .range(0,9)</span><br><span class="line">  .groupBy(new Function&lt;Integer, Object&gt;() &#123;</span><br><span class="line">      @Override</span><br><span class="line">      public Object apply(Integer integer) throws Exception &#123;</span><br><span class="line">          return integer%2==0 ? &quot;1&quot;:&quot;2&quot;;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  .subscribe(new Consumer&lt;GroupedObservable&lt;Object, Integer&gt;&gt;() &#123;</span><br><span class="line">      @Override</span><br><span class="line">      public void accept(GroupedObservable&lt;Object, Integer&gt; objectIntegerGroupedObservable) throws Exception &#123;</span><br><span class="line">          if (objectIntegerGroupedObservable.getKey().equals(&quot;1&quot;))</span><br><span class="line">              objectIntegerGroupedObservable.subscribe(System.out::println);</span><br><span class="line">          &#125;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<h2 id="buffer-和-window"><a href="#buffer-和-window" class="headerlink" title="buffer() 和 window()"></a>buffer() 和 window()</h2><h3 id="buffer"><a href="#buffer" class="headerlink" title="buffer()"></a>buffer()</h3><p>&emsp;&emsp;指定缓存大小 返回一个 Observable&lt;List<Object>&gt; 对象, 发送缓存的集合</Object></p>
<h4 id="buffer-count-skip"><a href="#buffer-count-skip" class="headerlink" title="buffer(count, skip)"></a>buffer(count, skip)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Observable.range(0,9)</span><br><span class="line">        .buffer(5,1)</span><br><span class="line">        .subscribe(System.out::println);</span><br></pre></td></tr></table></figure>
<p>print:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[0, 1, 2, 3, 4]</span><br><span class="line">[1, 2, 3, 4, 5]</span><br><span class="line">[2, 3, 4, 5, 6]</span><br><span class="line">[3, 4, 5, 6, 7]</span><br><span class="line">[4, 5, 6, 7, 8]</span><br><span class="line">[5, 6, 7, 8]</span><br><span class="line">[6, 7, 8]</span><br><span class="line">[7, 8]</span><br><span class="line">[8]</span><br></pre></td></tr></table></figure>
<h3 id="window"><a href="#window" class="headerlink" title="window()"></a>window()</h3><p>&emsp;&emsp;定期将来自原始  Observable 的数据分解为多个窗口, 发射这些窗口, 而不是发射每一项数据.(并不发射原始数据包, 发射 Observables, 每一个都发射原始 Observable 数据的一个子集, 最后发射一个 onComplete() 通知 )  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Observable</span><br><span class="line">    .range(1,10)</span><br><span class="line">    .window(2)</span><br><span class="line">    .subscribe(integerObservable -&gt; &#123;</span><br><span class="line">        System.out.println(&quot;on next&quot;);</span><br><span class="line">        integerObservable.subscribe(System.out::println);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<p>print:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">on next</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">on next</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">on next</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">on next</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">on next</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td></tr></table></figure>
<h2 id="debounce"><a href="#debounce" class="headerlink" title="debounce"></a>debounce</h2><p>&emsp;&emsp;定期检测发送流, 当这段时间内有多个数据发送, 忽略, 只有一个数据发送则通过.  </p>
<h1 id="条件操作符和布尔操作符"><a href="#条件操作符和布尔操作符" class="headerlink" title="条件操作符和布尔操作符"></a>条件操作符和布尔操作符</h1><p>&emsp;&emsp;布尔操作符返回的结果全部为 布尔值, 而条件操作符则会根据条件进行数据发射或变换被观察者.</p>
<h2 id="all-contains-和-amb"><a href="#all-contains-和-amb" class="headerlink" title="all, contains 和 amb"></a>all, contains 和 amb</h2><h3 id="all"><a href="#all" class="headerlink" title="all"></a>all</h3><p>&emsp;&emsp;传递一个谓词函数作为参数, 返回一个只发射单个布尔值的  Observable, 默认不在任何特定的调度器上执行;</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Observable</span><br><span class="line">    .just(1,2,3,4,5)</span><br><span class="line">    .all(integer -&gt; integer&lt;10)</span><br><span class="line">    .subscribe(System.out::print);</span><br></pre></td></tr></table></figure>
<p>print</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">true</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">### contains  </span><br><span class="line">&amp;emsp;&amp;emsp;传递一个特定的值, 判断 Observable 是否发送该特定值  </span><br><span class="line">### amb</span><br><span class="line">&amp;emsp;&amp;emsp;只发射首先发射的 Observable  </span><br></pre></td></tr></table></figure>
<p>Observable<br>  .ambArray(<br>        Observable.just(1,2,3).delay(1, TimeUnit.SECONDS),<br>        Observable.just(4,5,6)<br>        )<br>  .subscribe(System.out::println);</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print:</span><br></pre></td></tr></table></figure>
<p>4<br>5<br>6</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">## defaultEmpty  </span><br><span class="line">&amp;emsp;&amp;emsp;发射来自原始 Observable 的数据, 如果原始 Observable 为空, 发射一个作为参数传入的默认值  </span><br><span class="line"></span><br><span class="line">## sequenceEqual  </span><br><span class="line">&amp;emsp;&amp;emsp;判断两个 Observable 是否发射相同的数据序列  </span><br><span class="line">&amp;emsp;&amp;emsp;可传入谓词函数作为判断依据  </span><br><span class="line"></span><br><span class="line">## skipUntil 和 skipWhile  </span><br><span class="line">### skipUntil( Observable&lt;? extends Object&gt; )  </span><br><span class="line">&amp;emsp;&amp;emsp;直到作为参数的 Observable 发射数据之前, 忽略所有原 Observable 发射的数据   </span><br><span class="line">### skipWhile( Function&lt;? extends Object&gt;)</span><br><span class="line">&amp;emsp;&amp;emsp;忽略所有数据, 直到参数函数返回第一个 false;</span><br><span class="line">## takeUntil 和 takeWhile  </span><br><span class="line">### takeUntil  </span><br><span class="line">&amp;emsp;&amp;emsp;发射原数据直到检测到第一个谓词函数返回真的数据, 忽略该数据之后的所有数据  </span><br><span class="line">### takeWhile  </span><br><span class="line">&amp;emsp;&amp;emsp;发射所有数据直到第一个谓词函数返回 false 的数据  </span><br><span class="line"></span><br><span class="line"># 合并与连接  </span><br><span class="line">## merge 和 zip  </span><br><span class="line">### merge(Observable&lt;? extends Object&gt;[])  </span><br><span class="line">&amp;emsp;&amp;emsp;合并至多四个 Observable, 按照时间线并行发射数据, 如果任何一个发射了 onError 通知, 则 merge 生成的 Observable 也会立即以 onError 通知终止, 如果想让它继续发射数据直到最后才报告错误, 可以使用 mergeDelayError  </span><br><span class="line">### zip(Observable&lt;? extends Object&gt;[], Function&lt;&gt;)  </span><br><span class="line">&amp;emsp;&amp;emsp;返回每次发射以 Function 压缩后的单个数据的 Observable  </span><br><span class="line"></span><br><span class="line">## combineLastest 和 join  </span><br><span class="line">### combineLastest(Observable&lt;? extends Object&gt;[], Function&lt;&gt;)</span><br><span class="line">&amp;emsp;&amp;emsp;与 zip 类似, zip 只有当每个 Observable 都发射一条数据之后再进行压缩处理, combineLastest 则有单个 Observable 发射数据时便进行合并处理( 采用当前发射的数据和其他参与压缩的 Observable 最近发射的数据)  </span><br><span class="line">### join</span><br></pre></td></tr></table></figure>
<p>@SchedulerSupport(SchedulerSupport.NONE)<br>    public final &lt;TRight, TLeftEnd, TRightEnd, R&gt; Observable<R> join(<br>            ObservableSource&lt;? extends TRight&gt; other,<br>            Function&lt;? super T, ? extends ObservableSource<TLeftEnd>&gt; leftEnd,<br>            Function&lt;? super TRight, ? extends ObservableSource<TRightEnd>&gt; rightEnd,<br>            BiFunction&lt;? super T, ? super TRight, ? extends R&gt; resultSelector<br>                    ) {<br>        return RxJavaPlugins.onAssembly(new ObservableJoin&lt;T, TRight, TLeftEnd, TRightEnd, R&gt;(<br>                this, other, leftEnd, rightEnd, resultSelector));<br>    }</TRightEnd></TLeftEnd></R></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line">Observable&lt;Long&gt; o1 = Observable.interval(1, TimeUnit.SECONDS);</span><br><span class="line">Observable&lt;Long&gt; o2 = Observable.interval(1, TimeUnit.SECONDS);</span><br><span class="line">o1.join(</span><br><span class="line">                o2,</span><br><span class="line">                along -&gt; Observable.timer(5, TimeUnit.SECONDS),</span><br><span class="line">                along -&gt; Observable.timer(10, TimeUnit.SECONDS),</span><br><span class="line">                (integer, integer2) -&gt; &quot;integer1 &quot; + integer + &quot;: integer2 &quot; + integer2</span><br><span class="line">        ).subscribe(s -&gt; System.out.println(&quot;onNext&quot; + s))</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;两个 Observable 按照预定顺序发射数据, 每次发射数据时找到另一个最近 t 时间内 ( 第二三参数返回的  Observable 生命周期时长) 发射过的数据, 根据 resultSelector 函数进行连接, 发射连接后的数据.  </p>
<h2 id="startWith"><a href="#startWith" class="headerlink" title="startWith"></a>startWith</h2><p>&emsp;&emsp;在开端插入几个序列<br>三种重载形式:</p>
<ol>
<li>startWith(T)</li>
<li>startWith(ObservableSource&lt;? extends T&gt;)</li>
<li>startWith(Iterable&lt;? extends T&gt;)  (同时存在 startWithArray(&lt;? extends T&gt;[])) 运算符  </li>
</ol>
<h2 id="connect-publish-和-refCount"><a href="#connect-publish-和-refCount" class="headerlink" title="connect, publish 和 refCount"></a>connect, publish 和 refCount</h2><p>&emsp;&emsp;均为与 ConnectableObservable 相关的操作符  </p>
<h3 id="ConnectableObservable"><a href="#ConnectableObservable" class="headerlink" title="ConnectableObservable"></a>ConnectableObservable</h3><p>&emsp;&emsp;只有对其使用 connect 操作符时才发射数据, 属于<strong>Hot Observable</strong></p>
<h3 id="connect"><a href="#connect" class="headerlink" title="connect"></a>connect</h3><p>&emsp;&emsp;触发 ConnectableObservable 发射数据, 可以等所有的 Observer 都订阅了再进行 connect 发射数据   </p>
<h3 id="publish"><a href="#publish" class="headerlink" title="publish"></a>publish</h3><p>&emsp;&emsp;将普通的 Observable 转换为 ConnectableObservable  </p>
<h3 id="refCount"><a href="#refCount" class="headerlink" title="refCount"></a>refCount</h3><p>&emsp;&emsp;将 ConnectableObservable 转换为较普通的 Observable, 当有 Observer 订阅时自动 connect 发射数据, 无订阅时停止数据流  </p>
<h2 id="replay"><a href="#replay" class="headerlink" title="replay"></a>replay</h2><p>&emsp;&emsp;返回一个保证所有的 Observer 无论何时订阅均收到相同的数据序列的 ConnectableObservable;</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Observable&lt;Long&gt; obs = Observable.interval(1, TimeUnit.SECONDS).take(6);</span><br><span class="line">ConnectableObservable&lt;Long&gt; cob = obs.replay();</span><br><span class="line">cob.connect();</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;replay 有多个重载方法, 可以指定最大缓存数量, 调度器等<br>&emsp;&emsp;<strong>ConnectableObservable 切换调度器只能通过 replay 实现</strong></p>
<h1 id="RxJava-背压"><a href="#RxJava-背压" class="headerlink" title="RxJava 背压"></a>RxJava 背压</h1><h2 id="背压-Back-Pressure"><a href="#背压-Back-Pressure" class="headerlink" title="背压(Back Pressure)"></a>背压(Back Pressure)</h2><p>&emsp;&emsp;被观察者发送数据速度太快以至于它的操作符或者观察者来不及处理数据的场景.</p>
<blockquote>
<p>官方维基百科<br>&emsp;&emsp;In RxJava it is not difficult to get into a situation in which an Observable is emittting items more rapidly than an operatot or subscriber can consume them. This presents the problem of what to do with such a growing backlog of unconsumed items  </p>
</blockquote>
<ol>
<li>异步场景</li>
<li>Push 模型  </li>
</ol>
<p>&emsp;&emsp;** RxJava 中 Flowable 专门支持背压, 默认队列大小为 128, 且要求所有操作符强制支持背压**  </p>
<h2 id="Rxjava-2-X-的背压策略"><a href="#Rxjava-2-X-的背压策略" class="headerlink" title="Rxjava 2.X 的背压策略"></a>Rxjava 2.X 的背压策略</h2><p>** 见 <em>BackpressureStrategy</em> 源码**</p>
<h3 id="MISSSING"><a href="#MISSSING" class="headerlink" title="MISSSING"></a>MISSSING</h3><p>&emsp;&emsp;默认背压策略( 通过 create 方法创建的 Flowable 没有指定背压策略), 不会对通过 onNext 发射的数据做缓存或丢弃处理, 需要下游通过背压操作符(** onBackpressureBuffer() / onBackpressureDrop() / onBackpressureLatest() **) 指定背压策略  </p>
<h3 id="ERROR"><a href="#ERROR" class="headerlink" title="ERROR"></a>ERROR</h3><p>&emsp;&emsp;如果放入 Flowable 的异步缓存池中的数据超限了(默认大小 128), 则会抛出 <em><strong>MisssingBackpressureException</strong></em> 异常</p>
<h3 id="BUFFER"><a href="#BUFFER" class="headerlink" title="BUFFER"></a>BUFFER</h3><p>&emsp;&emsp;使缓存池大小无限制, 可能导致内存溢出 程序无响应</p>
<h3 id="DROP"><a href="#DROP" class="headerlink" title="DROP"></a>DROP</h3><p>&emsp;&emsp;如果缓存池满了, 丢弃将要进入缓存池中的数据</p>
<h3 id="LATEST"><a href="#LATEST" class="headerlink" title="LATEST"></a>LATEST</h3><p>&emsp;&emsp;丢弃将要进入缓存池中的数据, 但会强行将最后一个数据压入缓存池<br><br><br><br>Flowable 不仅可以通过 create 创建时指定背压策略. 还可以用其他操作符指定背压策略.( <strong>onBackpressureXXX()</strong>)  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Flowable</span><br><span class="line">  .interval(1,TimeUnit.SECONDS)</span><br><span class="line">  .onBackpressureBuffer()</span><br><span class="line">  .subscribe(System.out::println)</span><br></pre></td></tr></table></figure>

<h1 id="Disposed-和-Transformer-的使用"><a href="#Disposed-和-Transformer-的使用" class="headerlink" title="Disposed 和 Transformer 的使用"></a>Disposed 和 Transformer 的使用</h1><h2 id="Disposed"><a href="#Disposed" class="headerlink" title="Disposed"></a>Disposed</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface Disposable&#123;</span><br><span class="line">  void dispose();</span><br><span class="line">  boolean isDisposed();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;监听当前 Observable 是否被订阅</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Disposable disposable = Observable</span><br><span class="line">                          .just(&quot;Hello world!&quot;)</span><br><span class="line">                          .subscribe(System.out::println);</span><br><span class="line">disposable.dispose();// 解除订阅</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;CompositeDisposable 可以用来管理订阅<br>&emsp;&emsp;CompositeDisposable.add() 增加管理的 Disposable<br>&emsp;&emsp;CompositeDisposable.clear() 切断所有订阅  </p>
<h2 id="RxLifecycle-和-AutoDispose"><a href="#RxLifecycle-和-AutoDispose" class="headerlink" title="RxLifecycle 和 AutoDispose"></a>RxLifecycle 和 AutoDispose</h2><h3 id="RxLifecycle"><a href="#RxLifecycle" class="headerlink" title="RxLifecycle"></a>RxLifecycle</h3><blockquote>
<p>GitHub 地址 <a target="_blank" rel="noopener" href="https://github.com/trello/RxLifecycle">https://github.com/trello/RxLifecycle</a><br>知乎版地址 <a target="_blank" rel="noopener" href="https://github.com/zhihu/RxLifecycle">https://github.com/zhihu/RxLifecycle</a> (使用更加简单)</p>
</blockquote>
<p>添加依赖</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">compile &#x27;com.trello.rxlifecycle2:rxlifecycle-components:2.1.0&#x27;</span><br><span class="line">compile &#x27;com.trello.rxlifecycle2:rxlifecycle-navi:2.1.0&#x27;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;默认情况下, RxLifecycle 将在辅助生命周期事件中终止  Observable.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void onResume()&#123;</span><br><span class="line">    super.onResume();</span><br><span class="line">    myObservalbe</span><br><span class="line">      .compose(RxLifecycleAndroid.bindActivity(lifecycle))// lifecycle 继承自 RxAppCompatActivity</span><br><span class="line">      .subscribe();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;或者可以指定事件  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void onResume()&#123;</span><br><span class="line">    super.onResume();</span><br><span class="line">    myObservalbe</span><br><span class="line">      .compose(RxLifecycle.bindUntilEvent(llifecycle, ActivityEvent.DESTROY))//在 onDestory() 中终止 Observable 序列.</span><br><span class="line">      .subscribe();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="AutoDispose"><a href="#AutoDispose" class="headerlink" title="AutoDispose"></a>AutoDispose</h3><p>&emsp;&emsp;不仅可以在 Android 上使用, 还可以在 J2EE 上使用.</p>
<blockquote>
<p>GitHub 地址 : <a target="_blank" rel="noopener" href="https://github.com/uber/AutoDispose">https://github.com/uber/AutoDispose</a>  </p>
</blockquote>
<h2 id="Transformer-在-RxJava-中的使用"><a href="#Transformer-在-RxJava-中的使用" class="headerlink" title="Transformer 在 RxJava 中的使用"></a>Transformer 在 RxJava 中的使用</h2><h3 id="Transformer-的用途"><a href="#Transformer-的用途" class="headerlink" title="Transformer 的用途"></a>Transformer 的用途</h3><p>&emsp;&emsp;根据参数转换 Observable/Flowable/Single/Completable/Maybe为另一个 被观察者</p>
<h3 id="与-compose-操作符结合使用"><a href="#与-compose-操作符结合使用" class="headerlink" title="与 compose 操作符结合使用"></a>与 compose 操作符结合使用</h3><p>&emsp;&emsp; compose() 能从数据流中拿到原始的被观察者.然后根据传入的 Transformer 参数转换 被观察者给下游  </p>
<h1 id="Rxjava-并行编程"><a href="#Rxjava-并行编程" class="headerlink" title="Rxjava 并行编程"></a>Rxjava 并行编程</h1><hr>
<h2 id="饿到先不看了"><a href="#饿到先不看了" class="headerlink" title="饿到先不看了"></a>饿到先不看了</h2><hr>
<h1 id="RxBinding"><a href="#RxBinding" class="headerlink" title="RxBinding"></a>RxBinding</h1><p>&emsp;&emsp;可以将 UI 控件转换为 Observable 对象, 把事件当做数据流处理<br>&emsp;&emsp;View 的 onClick 事件, RxView.clicks(view) 即可获取一个 Observable 对象, 每次点击 Observer 即可通过 onNext 回调知道用户点击了 View</p>
<h2 id="常用的库-kotlin-版依赖"><a href="#常用的库-kotlin-版依赖" class="headerlink" title="常用的库(kotlin 版依赖)"></a>常用的库(kotlin 版依赖)</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// Android 平台 bindings</span><br><span class="line">implementation &#x27;com.jakewharton.rxbinding2:rxbinding-kotlin:2.0.0&#x27;</span><br><span class="line">// 对应包的 bindings</span><br><span class="line">implementation &#x27;com.jakewharton.rxbinding2:rxbinding-support-v4-kotlin:2.0.0&#x27;</span><br><span class="line">implementation &#x27;com.jakewharton.rxbinding2:rxbinding-appcompat-v7-kotlin:2.0.0&#x27;</span><br><span class="line">implementation &#x27;com.jakewharton.rxbinding2:rxbinding-design-kotlin:2.0.0&#x27;</span><br><span class="line">implementation &#x27;com.jakewharton.rxbinding2:rxbinding-recyclerview-v7-kotlin:2.0.0&#x27;</span><br><span class="line">implementation &#x27;com.jakewharton.rxbinding2:rxbinding-leanback-v17-kotlin:2.0.0&#x27;</span><br></pre></td></tr></table></figure>

<h2 id="RxBinding-常见使用场景"><a href="#RxBinding-常见使用场景" class="headerlink" title="RxBinding 常见使用场景"></a>RxBinding 常见使用场景</h2><h3 id="点击事件"><a href="#点击事件" class="headerlink" title="点击事件"></a>点击事件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">RxView.clicks(view)</span><br><span class="line">  .subscribe(new Consumer&lt;Object&gt;()&#123;</span><br><span class="line">      @Override</span><br><span class="line">      publiv void accept(@NonNull Object o) throws Exception&#123;</span><br><span class="line">        // doSomething</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 点击</span><br><span class="line">RxView.clicks(mainSingleClick)</span><br><span class="line">               .subscribe&#123; mainSingleClick.visibility = View.GONE &#125;</span><br><span class="line">// 长按</span><br><span class="line">RxView.longClicks(mainLongClick)</span><br><span class="line">               .subscribe&#123; mainLongClick.visibility = View.GONE &#125;</span><br><span class="line">// 避免重复点击</span><br><span class="line">RxView.clicks(mainAvoidclicks)</span><br><span class="line">               .throttleFirst(10, TimeUnit.SECONDS) // 只发射 10秒内第一个数据</span><br><span class="line">               .subscribe&#123;  Toast.makeText(this, &quot;click&quot;, Toast.LENGTH_LONG).show()&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// TextView 文字改变  </span><br><span class="line">Observable&lt;CharSequence&gt; Observable = RxTextView.textChanges(phone);</span><br></pre></td></tr></table></figure>
<h3 id="对-Recyclerview-的支持"><a href="#对-Recyclerview-的支持" class="headerlink" title="对 Recyclerview 的支持"></a>对 Recyclerview 的支持</h3><p>&emsp;&emsp; rxbinding-recycleview-v7<br>** 提供以下集中状态的观察 **  </p>
<ol>
<li><strong>scrollStateChanges</strong> 观察滚动状态</li>
<li><strong>scrollEvents</strong> 观察滚动事件</li>
<li><strong>childAttachStateChangeEvents</strong> 观察 child view 的 detached 状态, 当 LayoutManager<br>或者 RecyclerView 认为不再需要一个 child view 时, 就会调用这个方法, 如果 child view 占用<br>资源, 则应当释放资源  </li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">RxRecyclerView</span><br><span class="line">  .scrollStateChanges(recycleview)</span><br><span class="line">  .subscribe(new Consumer&lt;Integer&gt;()&#123;</span><br><span class="line">    publiv void accept(Integr scrollState) throws Exception&#123;</span><br><span class="line">      // do something</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">// scrollState</span><br><span class="line">public static final int SCROLL_STATE_IDLE = 0; // 当前没有滚动</span><br><span class="line">public static final int SCROLL_STATE_DRAGGING = 1 ; // 正在被拖动</span><br><span class="line">public static final int SCROLL_STATE_SETTLING = 2; // 手已经离开屏幕, 处在&quot;惯性&quot;移动中</span><br></pre></td></tr></table></figure>
<h3 id="多次监听"><a href="#多次监听" class="headerlink" title="多次监听"></a>多次监听</h3><p>&emsp;&emsp;使用 publish, share, replay 等转换为 hot Observable 订阅多个 Observer</p>
<h2 id="RxBinding-结合-RxPermissions"><a href="#RxBinding-结合-RxPermissions" class="headerlink" title="RxBinding 结合 RxPermissions"></a>RxBinding 结合 RxPermissions</h2><p>targetSdkVersion 23以上且运行在 Android 6.0 以上的设备时需要动态申请危险权限  </p>
<h3 id="RxPermissions"><a href="#RxPermissions" class="headerlink" title="RxPermissions"></a>RxPermissions</h3><p><code>implementation &#39;com.tbruyelle.rxpermissions2:rxpermissions:0.9.5@aar&#39;</code><br>** 使用**  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 先创建 rxPermissions 对象</span><br><span class="line">var rxPermissions = RxPermissions(avtivity:Activity)</span><br><span class="line">rxPermissions</span><br><span class="line">    .request(Manifest.permission.CAMERA</span><br><span class="line">            ,Manifest.permission.CALL_PHONE)//请求的权限, 接收 vararg 参数, 都授权才发射 true 否则 发射 false</span><br><span class="line">    .subscribe(Consumer&lt;Boolean&gt; &#123; &#125;)</span><br></pre></td></tr></table></figure>
<h2 id="结合-compose-链式调用"><a href="#结合-compose-链式调用" class="headerlink" title="结合 compose 链式调用"></a>结合 compose 链式调用</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RxView</span><br><span class="line">  .clicks(view)</span><br><span class="line">  .compose(rxPermissions.ensure(Manifest.perm</span><br><span class="line">    .CALL_PHONE)) // 返回一个转换器并申请权限</span><br><span class="line">  .subscribe(Consumer&lt;Boolean&gt;&#123;&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="在-android-中使用-RxJava-致命缺陷"><a href="#在-android-中使用-RxJava-致命缺陷" class="headerlink" title="在 android 中使用 RxJava 致命缺陷"></a>在 android 中使用 RxJava 致命缺陷</h2><p>&emsp;&emsp;不完整的订阅会导致内存泄露, 当 Android 系统尝试销毁包含着正在运行 Observalbe 的 Activity/Fragment 时, 由于 Observable 正在运行, 其观察者仍然会持有该 Activity/Fragment 的引用, 因此系统无法对该 Activity/Fragment 进行垃圾回收.</p>
<h1 id="RxAndroid-和-Retrofit"><a href="#RxAndroid-和-Retrofit" class="headerlink" title="RxAndroid 和  Retrofit"></a>RxAndroid 和  Retrofit</h1><h2 id="RxAndroid"><a href="#RxAndroid" class="headerlink" title="RxAndroid"></a>RxAndroid</h2><p><strong>依赖于 RxJava 才能使用</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">implementation &#x27;io.reactivex.rxjava2:rxjava:2.0.2&#x27;</span><br><span class="line">implementation &#x27;io.reactivex.rxjava2:rxandroid:2.0.1&#x27;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;提供了一个调度程序 AndroidSchedulers;  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AndroidSchedulers.mainThread();</span><br><span class="line">AndroidSchedulers.from(Looper looper);</span><br></pre></td></tr></table></figure>

<h2 id="Retrofit"><a href="#Retrofit" class="headerlink" title="Retrofit"></a>Retrofit</h2><blockquote>
<p>GitHub <a target="_blank" rel="noopener" href="https://github.com/square/retrofit">https://github.com/square/retrofit</a></p>
</blockquote>
<p>底层依赖 OkHttp<br><strong>Retrofit 特点</strong>  </p>
<ol>
<li>Retrofit 可插拔的,允许不同的执行机制及其库用于执行 http 调用. 允许 API 请求, 与应用程序其余部分中任何现有线程模型和任务框架无缝结合. 提供常见适配器:</li>
</ol>
<ul>
<li> Rxjava1.x Observable &amp; Single (com.squareup.retrofit2:adapter-rxjava)</li>
<li>Rxjava2.x Observable, Flowable, Single, Completable &amp; Maybe (com.squareup.retrofit2:adapter-rxjava2)</li>
<li>Guava ListenableFuture</li>
<li>java8 CompletableFuture (com.squareup.retrofit2:adapter-java8)</li>
</ul>
<ol start="2">
<li>允许不同的序列化格式及其库, 用于将 Java 类型转换为其 http 表示形式, 并将 http 实体解析为 Java 类型</li>
</ol>
<ul>
<li>Gson (com.squareup.retrofit2:converter-gson)</li>
<li>Jackson</li>
<li>Moshi</li>
</ul>
<p><strong>Okhttp特点</strong>  </p>
<ol>
<li>支持 HTTP2/SPDY</li>
<li>socket 自动选择最优路线, 并支持自动重连</li>
<li>拥有自动维护的 socket 连接池, 减少握手次数</li>
<li>拥有队列线程池, 易于并发编程</li>
<li>拥有 Interceptors 处理请求与响应 (透明 GZIP 压缩, LOGGING 等)</li>
<li>基于 Headers 的缓存策略</li>
</ol>
<h2 id="Rxjava-与-Retrofit-的配合"><a href="#Rxjava-与-Retrofit-的配合" class="headerlink" title="Rxjava 与 Retrofit 的配合"></a>Rxjava 与 Retrofit 的配合</h2><h3 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">implementation &#x27;com.squareup.retrofit2:retrofit:2.3.0&#x27;</span><br><span class="line">implementation &#x27;com.squareup.retrofit2:adapter-rxjava2:2.3.0&#x27;</span><br></pre></td></tr></table></figure>
<h3 id="创建-RetrofitManager"><a href="#创建-RetrofitManager" class="headerlink" title="创建 RetrofitManager"></a>创建 RetrofitManager</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">package com.example.silence.rxstudy;</span><br><span class="line"></span><br><span class="line">import com.safframework.http.interceptor.LoggingInterceptor;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">import okhttp3.Interceptor;</span><br><span class="line">import okhttp3.OkHttpClient;</span><br><span class="line">import okhttp3.Response;</span><br><span class="line">import retrofit2.Retrofit;</span><br><span class="line">import retrofit2.adapter.rxjava2.RxJava2CallAdapterFactory;</span><br><span class="line">import retrofit2.converter.fastjson.FastJsonConverterFactory;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Created by silence on 18-7-15.</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">public class RetrofitManager &#123;</span><br><span class="line">    private static Retrofit retrofit;</span><br><span class="line"></span><br><span class="line">    public static Retrofit retrofit() &#123;</span><br><span class="line">        if (null == retrofit) &#123;</span><br><span class="line">            OkHttpClient.Builder builder = new OkHttpClient.Builder();</span><br><span class="line">            builder.writeTimeout(30 * 1000, TimeUnit.MILLISECONDS);</span><br><span class="line">            builder.readTimeout(20 * 1000, TimeUnit.MILLISECONDS);</span><br><span class="line">            builder.connectTimeout(15 * 1000, TimeUnit.MILLISECONDS);</span><br><span class="line">            LoggingInterceptor loggingInterceptor =</span><br><span class="line">                    new LoggingInterceptor</span><br><span class="line">                            .Builder()</span><br><span class="line">                            .loggable(true)</span><br><span class="line">                            .request()</span><br><span class="line">                            .requestTag(&quot;Resquest&quot;)</span><br><span class="line">                            .response()</span><br><span class="line">                            .responseTag(&quot;Response&quot;)</span><br><span class="line">                            .build();</span><br><span class="line">            // 设置拦截器</span><br><span class="line">            builder.addInterceptor(loggingInterceptor);</span><br><span class="line"></span><br><span class="line">            OkHttpClient okHttpClient = builder.build();</span><br><span class="line">            retrofit= new Retrofit</span><br><span class="line">                    .Builder()</span><br><span class="line">                    .baseUrl(APIService.API_BASE_SERVER_URL)</span><br><span class="line">                    .addConverterFactory(FastJsonConverterFactory.create())</span><br><span class="line">                    .addCallAdapterFactory(RxJava2CallAdapterFactory.create())</span><br><span class="line">                    .client(okHttpClient)</span><br><span class="line">                    .build();</span><br><span class="line">        &#125;</span><br><span class="line">        return retrofit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="创建-APIService"><a href="#创建-APIService" class="headerlink" title="创建 APIService"></a>创建 APIService</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface APIService &#123;</span><br><span class="line">    String API_BASE_SERVER_URL = &quot;http://www.pm25.in/&quot;;</span><br><span class="line">    @GET(&quot;api/queryas/pm2.5.json&quot;)</span><br><span class="line">    Maybe&lt;List&lt;PM25Model&gt;&gt; pm25(@Query(&quot;city&quot;) String city, @Query(&quot;token&quot;) String token);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Retrofit各注解含义 <a target="_blank" rel="noopener" href="https://blog.csdn.net/qiang_xi/article/details/53959437">https://blog.csdn.net/qiang_xi/article/details/53959437</a></p>
</blockquote>
<h3 id="使用-Retrofit"><a href="#使用-Retrofit" class="headerlink" title="使用 Retrofit"></a>使用 Retrofit</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">APIService apiService = RetrofitManager.retrofit().create(APIService.class);</span><br><span class="line">apiService</span><br><span class="line">    .pm25(Constant.CITY, Constant.TOKEN)</span><br><span class="line">    .compose( upstream -&gt; &#123;</span><br><span class="line">            upstream</span><br><span class="line">                .subscribOn(Schedulers.io())</span><br><span class="line">                .observeOn(AndroidSchedulers.mainThread))</span><br><span class="line">    ).subscribe(pm25Model -&gt;&#123; // do Something;&#125;);  </span><br></pre></td></tr></table></figure>
<h1 id="开发-EventBus"><a href="#开发-EventBus" class="headerlink" title="开发 EventBus"></a>开发 EventBus</h1><h2 id="传统的-EventBus"><a href="#传统的-EventBus" class="headerlink" title="传统的 EventBus"></a>传统的 EventBus</h2><p>&emsp;&emsp;EventBus 是事件总线框架, 是一种消息发布-订阅的模式, 工作机制类似<br>于观察者模式, 通过通知者去注册观察者, 最后由通知者向观察者发布消息.<br>&emsp;&emsp;在 Android 开发中, 使用 EventBus 能够解耦 AsyncTask, Handler,<br>Thread, Broadcast 等各种组件, 除此之外还可以实现跨越多个 Fragment 之间的通信    </p>
<blockquote>
<p>Greenrobot 的 EventBus 官网: <a target="_blank" rel="noopener" href="https://greenrobot.org/eventbus/">https://greenrobot.org/eventbus/</a><br>GitHub : <a target="_blank" rel="noopener" href="https://github.com/greenrobot/EventBus">https://github.com/greenrobot/EventBus</a>  </p>
</blockquote>
<p><strong>EventBus</strong> 的主要角色如下  </p>
<ol>
<li>Event: 传递的事件对象</li>
<li>Subscriber: 事件的订阅者</li>
<li>Pulisher: 事件的发布者</li>
<li>ThreadMode: 定义方法在何种线程中执行<ul>
<li>MainUI 主线程</li>
<li>Background 后台线程</li>
<li>Posting 和发布者处在同一个线程</li>
<li>Async 异步线程</li>
</ul>
</li>
</ol>
<p><strong>推荐使用 RxJava 和 RxAndroid 开发自己的 EventBus</strong><br>待百度</p>
<h1 id="以下应该是-RxJava-2-x-实战第十四章以及以后的内容-暂时先补完-ssm-之后再看"><a href="#以下应该是-RxJava-2-x-实战第十四章以及以后的内容-暂时先补完-ssm-之后再看" class="headerlink" title="以下应该是 RxJava 2.x 实战第十四章以及以后的内容. 暂时先补完 ssm 之后再看"></a>以下应该是 RxJava 2.x 实战第十四章以及以后的内容. 暂时先补完 ssm 之后再看</h1> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=https://shiweiwong.github.io/notes/rxjava.html" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/notes/java_web.html" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            JavaWeb
          
        </div>
      </a>
    
    
      <a href="/notes/%E3%80%8AVueJs%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98%E3%80%8B.html" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">VueJs项目开发实战</div>
      </a>
    
  </nav>

  
   
     
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2021-2023
        <i class="ri-heart-fill heart_icon"></i> shiweiwong
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
 <script src='https://cdn.jsdelivr.net/npm/mermaid@10.3.0/+esm'></script> 
</footer>
    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="Shiweiwong&#39;s Blog"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/friends">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->
 
<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: ".tocbot",
    contentSelector: ".article-entry",
    headingSelector: "h1, h2, h3, h4, h5, h6",
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: "main",
    positionFixedSelector: ".tocbot",
    positionFixedClass: "is-position-fixed",
    fixedSidebarOffset: "auto",
  });
</script>

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->
 <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
      tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
  });

  MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for(i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
      }
  });
</script>

<script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.6/unpacked/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script>
  var ayerConfig = {
    mathjax: true,
  };
</script>

<!-- Katex -->

<!-- busuanzi  -->

<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>